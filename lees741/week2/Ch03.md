# Ch03. 파드: 쿠버네티스에서 컨테이너 실행

## 3.1 파드 소개
> 함께 배치된 컨테이너 그룹, 쿠버네티스의 기본 빌딩 블록

* 컨테이너를 개별적으로 배포하는 대신 컨테이너 그룹을 가지는 파드를 배포
* 컨테이너 그룹이라고 해서 파드가 항상 두 개 이상의 컨테이너를 포함하는 것은 아님
  * 일반적으로 파드는 하나의 컨테이너만 포함
  * 같은 파드에서 실행되는 컨테이너들은 항상 같은 노드에서 실행됨

### 3.1.1 파드가 필요한 이유
> 컨테이너를 개별 배포하는 대신 파드를 사용하는 이유?

#### 여러 프로세스를 실행하는 단일 컨테이너보다 다중 컨테이너가 나은 이유
> 하나의 컨테이너에서 여러 프로세스를 실행하면 되는 것 아닌가?

* IPC나 로컬 파일을 통해 통신하는 여러 프로세스로 구성된 애플리케이션이 있다고 가정
* 이 애플리케이션의 프로세스들은 모두 같은 노드에서 실행되어야 함
  * 컨테이너는 단일 프로세스를 실행하는 것을 목적으로 설계
  * 여러 프로세스를 실행하면 개별 프로세스가 실패하는 경우 자동으로 재시작하는 메커니즘을 포함해야 함
  * 여러 프로세스가 모두 동일한 표준 출력으로 로그를 기록하므로 구별이 어려움
* 위의 단점들 때문에 각 프로세스를 개별 컨테이너로 실행해야 함

### 3.1.2 파드 이해하기
> 여러 프로세스를 단일 컨테이너로 묶을 수 없기 때문에 여러 컨테이너를 하나의 단위로 관리할 수 있는 구조 필요

* 파드를 이용해 연관된 프로세스를 단일 컨테이너에서 모두 함께 실행되는 것처럼 동일한 환경을 제공 가능
* 그러면서도 각 프로세스를 격리된 상태로 유지 가능

#### 같은 파드에서 컨테이너 간 부분 격리
* 쿠버네티스는 파드 안에 있는 모든 컨테이너가 자체 네임스페이스가 아닌 동일한 리눅스 네임스페이스를 사용하도록 도커를 설정
* 파드 내 모든 컨테이너는 동일한 네트워크, UTS, IPC 네임스페이스 사용
* 그러나 파일시스템은 컨테이너 이미지에서 나오기 때문에 일반적으로 다른 컨테이너와 분리됨
  * 쿠버네티스의 볼륨 개념 이용해서 파일 디렉토리 공유하는 방법이 있음

#### 컨테이너가 동일한 IP와 포트 공간을 공유하는 방법
* 동일 파드 내 컨테이너는 동일한 네임스페이스를 사용하기 때문에 동일한 IP 주소와 포트 공간을 공유
* 따라서 동일 파드 내 컨테이너들은 각 프로세스가 같은 포트 번호를 사용하지 않도록 주의해야 함
* 동일 파드 내 모든 컨테이너는 로컬호스트를 통해 서로 통신할 수 있음

#### 파드 간 플랫 네트워크 소개
> 플랫 네트워크: 중간 단계없이 직접 통신할 수 있는 네트워크

* 쿠버네티스 클러스터의 모든 파드는 하나의 플랫 네트워크 주소 공간에 위치
* NAT(Network Address Translation)없이 다른 파드의 IP 주소를 사용해 접근 가능
* 네트워크 패킷의 source IP에서 상대 파드의 실제 IP 주소를 알아낼 수 있음
* **결과적으로 두 파드가 동일한 노드에 있는지는 중요하지 않으며 단순하게 IP 주소를 통해 통신 가능**

### 3.1.3 파드에서 컨테이너의 적절한 구성
#### 다계층 애플리케이션을 여러 파드로 분할
* 프론트엔드 서버와 백엔드 데이터베이스로 구성된 다계층 애플리케이션을 단일 파드에서 실행할 필요 없음
* 프론트엔드와 백엔드가 같은 파드에 위치한다면 항상 같은 노드에서 실행됨
* 굳이 같은 노드에서 실행될 필요가 없기 때문에 여러 파드로 분할한다면 쿠버네티스가 스케줄링을 통해 인프라스트럭처의 활용도 향상 가능

#### 개별 확장이 가능하도록 여러 파드로 분할
* 쿠버네티스는 개별 컨테이너를 수평으로 확장할 수 없고 대신 파드를 수평으로 확장
* 일반적으로 프론트엔드와 백엔드 구성요소는 서로 다른 스케일링 요구 사항을 가지기 때문에 여러 파드로 분할하는 것이 좋음

#### 파드에서 여러 컨테이너를 사용하는 경우
* 여러 컨테이너를 하나의 파드에 넣는 경우 일반적으로 메인이 되는 컨테이너 하나에 사이드카 컨테이너 여러 개가 일반적인 구성
* ex. `filebeat` 등 로그 로테이터와 수집기

#### 파드에서 여러 컨테이너를 사용하는 경우 결정
- 컨테이너를 같은 호스트에서 함께 실행해야 하는가?
- 여러 컨테이너가 모여 하나의 구성 요소를 나타내는가?
- 컨테이너가 함께 스케일링돼야 하는가?

## 3.2 YAML 또는 JSON 디스크립터로 파드 생성
> * 일반적으로 쿠버네티스 리소스는 쿠버네티스 API에 JSON 혹은 YAML 매니페스트를 전송해 생성
> * `kubectl run` 명령처럼 간단하게 리소스를 만들 수 있지만, 제한된 속성만 설정 가능
> * YAML 파일에 오브젝트를 정의하면 VCS로 관리 가능

### 3.2.1 기존 파드의 YAML 디스크립터 살펴보기
> `kubectl get` 명령과 `-o yaml` 옵션을 통해 YAML 정의를 볼 수 있음

#### 파드를 정의하는 주요 부분 소개
| 필드           | 설명                                        |
|--------------|-------------------------------------------|
| `apiVersion` | YAML에서 사용하는 쿠버네티스 API 버전                  |
| `kind`       | YAML이 설명하는 리소스 유형                         |
| `metadata`   | 이름, 네임스페이스, 레이블 및 파드에 관한 기타 정보 포함         |
| `spec`       | 파드 자체에 관한 실제 명세                           |
| `status`     | 파드 상태, 컨테이너 설명 및 상태, 파드 내부 IP 등 파드의 현재 정보 |

### 3.2.2 파드를 정의하는 간단한 YAML 정의 작성하기
```yaml
apiVersion: v1
kind: Pod
metadata:
  name: kubia-manual
spec:
  containers:
  - image: luksa/kubia
    name: kubia
    ports:
    - containerPort: 8080
      protocol: TCP
```
* 쿠버네티스 API v1 버전 사용, 파드 이름은 `kubia-manual`, `luksa/kubia` 이미지 기반 단일 컨테이너
* 컨테이너 이름은 `kubia`, 8080포트에서 연결 기다림

#### 컨테이너 포트 지정
* 포트를 지정해둔 것은 단지 정보에 불과, 생략해도 다른 클라이언트에서 열어 둔 포트로 접속 가능
* 다만, 명시적으로 스펙에 포트를 표시함으로써 클러스터를 사용하는 모든 사람이 노출된 포트를 확인 가능

> 💡 `kubectl explain`을 통해 사용 가능한 API 오브젝트 필드를 찾을 수 있음

### 3.2.3 kubectl create 명령으로 파드 만들기
```shell
$ kubectl create -f kubia-manual.yaml
pod "kubia-manual" created
```
* `kubectl create -f <파일 이름>`: YAML 또는 JSON 파일로 리소스를 만드는 데 사용

### 3.2.4 애플리케이션 로그 보기
* 일반적으로 컨테이너화된 애플리케이션은 로그를 파일보다는 표준 출력, 표준 에러에 남김
* 컨테이너 런타임(도커)은 이러한 스트림을 파일로 전달하고 다음 명령을 이용해 로그를 가져옴
  * `docker logs <container id>`
  * 노드에 직접 접속해 `docker logs` 명령으로 로그를 볼 수 있지만 쿠버네티스는 더 쉬운 방법을 제공

#### kubectl logs를 이용해 파드 로그 가져오기
```shell
$ kubectl logs kubia-manual
Kubia server starting...
```
> 💡 컨테이너 로그는 하루 단위로, 로그 파일이 10MB 크기에 도달할 때마다 로테이션
>
> `kubectl logs` 명령은 마지막으로 순환된 로그만 보여줌
* 단일 컨테이너로 이뤄진 파드라면 애플리케이션 로그를 가져오는 것이 매우 간단
* 여러 컨테이너로 이뤄진 파드는???

#### 컨테이너 이름을 지정해 다중 컨테이너 파드에서 로그 가져오기
```shell
$ kubectl logs kubia-manual -c kubia
Kubia server starting...
```
* 여러 컨테이너를 포함한 파드의 경우 `kubectl logs` 명령에 `-c <컨테이너 이름>` 옵션을 함께 사용해야 함
* 파드가 삭제되면 해당 로그도 같이 삭제됨

### 3.2.5 파드에 요청 보내기
> `kubectl expose` 명령으로 외부에서 파드에 접속할 수 있도록 서비스를 만들 수 있음
> 
> 그러나 파드에 테스트와 디버깅 목적으로 연결할 수 있는 다른 방법이 있음

#### 로컬 네트워크 포트를 파드의 포트로 포워딩
```shell
$ kubectl port-forward kubia-manual 8888:8080
```
* 머신의 로컬 포트를 파드의 포트로 향하게 할 수 있음

#### 포트 포워딩을 통해 파드 연결
```shell
$ curl localhost:8888
```
* `localhost:8888`에서 실행되고 있는 프록시를 통해 HTTP 요청을 해당 파드에 보낼 수 있음

## 3.3 레이블을 이용한 파드 구성
> 실제 애플리케이션을 배포할 때 많은 파드를 실행하게 되고 파드 수가 증가함에 따라 파드를 분류할 필요가 생김
> 
> 개발자와 시스템 관리자는 각 파드를 조직화해 특정 그룹에 속한 모든 파드에 관해 일괄적으로 작업하기를 원함

### 3.3.1 레이블 소개
* 레이블은 리소스에 첨부하는 키-값 쌍으로 모든 쿠버네티스 리소스를 조직화할 수 있는 강력한 쿠버네티스 기능
* 레이블 셀렉터를 통해 리소스를 선택
* 레이블 키가 리소스 내에서 고유하다면 여러 레이블을 가질 수 있음
* 리소스를 생성할 때 레이블을 붙일 수도 있고 나중에 추가하거나 기존 레이블 수정도 가능

### 3.3.2 파드를 생성할 때 레이블 지정
```yaml
apiVersion: v1
kind: Pod
metadata:
  name: kubia-manual-v2
  labels:
    creation_method: manual
    env: prod
spec:
  containers:
  - image: luksa/kubia
    name: kubia
    ports:
    - containerPort: 8080
      protocol: TCP
```
* 레이블 `creation_method=manual`과 `env=prod`를 `metadata.labels` 섹션에 포함
* `kubectl get pods` 명령은 레이블을 안 보여주는 것이 디폴트, `--show-labels` 사용해 볼 수 있음
  * 모든 레이블 대신 관심있는 레이블만 보고 싶으면 `-L`로 지정해 각 레이블을 자체 열에 표시 가능
  ```shell
  $ kubectl get pods -L creation_method,env
  ```

### 3.3.3 기존 파드 레이블 수정
> 기존 레이블을 변경할 때는 `--overwrite` 옵션이 필요
```shell
$ kubectl label po kubia-manual-v2 env=debug --overwrite
```

## 3.4 레이블 셀렉터를 이용한 파드 부분 집합 나열
> 레이블 셀렉터를 통해 특정 레이블로 태그된 파드의 부분 집합을 선택해 작업 수행 가능
- 특정한 키를 포함하거나 포함하지 않는 레이블
- 특정한 키와 값을 가진 레이블
- 특정한 키를 갖고 있지만, 다른 값을 가진 레이블

### 3.4.1 레이블 셀렉터를 사용해 파드 나열
> `-l` 옵션을 통해 레이블 셀렉터 사용 가능

| 셀렉터                         | 설명                                      |
|-----------------------------|-----------------------------------------|
| `-l <key>`                  | 특정한 키 레이블을 가지는 리소스                      |
| `-l '!<key>'`               | 특정한 키 레이블을 가지지 않는 리소스                   |
| `-l <key>=<value>`          | 특정한 키와 값 레이블을 가지는 리소스                   |
| `-l <key>!=<value>`         | 특정한 키 레이블을 가지는 리소스 중에 특정 값이 아닌 리소스      |
| `-l <key> in (<values>)`    | 특정한 키 레이블 값이 `<values>`에 포함되는 리소스       |
| `-l <key> notin (<values>)` | 특정한 키 레이블 값이 `<values>`에 포함되지 않는 리소스    |

### 3.4.2 레이블 셀렉터에서 여러 조건 사용
> 쉼표로 구분된 여러 기준을 포함하는 셀렉터도 가능 (AND 조건)
* 레이블 셀렉터는 `kubectl`에서만 사용하는 것이 아니라 쿠버네티스 내부에서도 사용

## 3.5 레이블과 셀렉터를 이용해 파드 스케줄링 제한
> 파드를 스케줄링할 때 노드를 특정하고 싶은 경우가 있음
>
> ex. 하드웨어 인프라가 동일하지 않은 경우
> 
> 파드가 어떤 노드에 스케줄링돼야 하는지 구체적으로 지정하는 대신 노드 요구 사항 기술
> 
> 쿠버네티스는 셀렉터를 통해 요구 사항을 만족하는 노드 선택

### 3.5.1 워커 노드 분류에 레이블 사용
> 노드에도 레이블 부착 가능
* 일반적으로 노드를 클러스터에 추가할 때 노드가 제공하는 하드웨어나 스케줄링시 유용한 기타 사항을 레이블로 지정
  * ex. `gpu=true`

### 3.5.2 특정 노드에 파드 스케줄링
```yaml
apiVersion: v1
kind: Pod
metadata:
  name: kubia-gpu
spec:
  nodeSelector:
    gpu: "true"
  containers:
  - image: luksa/kubia
    name: kubia
```
* `spec.nodeSelector`에 레이블 셀렉터를 추가해 파드가 특정 조건의 노드에만 스케줄링 되도록 할 수 있음
> 💡 각 노드에는 고유한 레이블(`kubernetes.io/hostname`)이 있기 때문에 파드를 하나의 특정 노드에만 스케줄링 하는 것도 가능하지만,
> 해당 노드가 오프라인 상태라면 파드가 스케줄링 되지 않을 수도 있기 때문에 단일 노드를 특정하기보다는 노드의 논리적인 그룹을 선택하는 것이 좋음

## 3.6 파드에 어노테이션 달기
> 어노테이션은 키-값 쌍으로 레이블과 유사하지만 식별 정보를 갖지 않고 셀렉터를 통해 선택할 수 없음
* 일반적으로 새로운 기능 테스트할 때 새로운 필드를 바로 도입하는 대신 어노테이션 사용
* 또한, 부가적인 설명을 추가할 때도 사용됨
  * ex. 오브젝트를 만든 사람 이름을 어노테이션으로 지정

### 3.6.1 오브젝트의 어노테이션 조회
* `kubectl describe` 명령을 이용하거나 YAML 내용 중 `metadata.annotations`에서 확인 가능
* 레이블보다 상대적으로 큰 데이터 저장 가능 (256KB까지)

### 3.6.2 어노테이션 추가 및 수정
* 레이블과 비슷하게 `kubectl annotate` 명령 사용해 생성할 때 추가하거나 이후 수정도 가능

## 3.7 네임스페이스를 사용한 리소스 그룹화
> 오브젝트는 여러 레이블을 가질 수 있기 때문에 오브젝트 그룹은 서로 겹쳐질 수 있음
> 
> 오브젝트를 겹치지 않는 그룹으로 분할하려면 네임스페이스로 그룹화

### 3.7.1 네임스페이스의 필요성
* 리소스를 prod, dev, QA 환경 등으로 나누어 이름을 중복해 사용할 수 있음
* 즉, 서로 다른 네임스페이스는 동일한 이름의 리소스를 가질 수 있음
* 노드 리소스처럼 네임스페이스 안에 속하지 않는 리소스도 존재 (전역 리소스)

### 3.7.2 다른 네임스페이스와 파드 살펴보기
* `kubectl get ns` 명령을 통해 클러스터에 있는 모든 네임스페이스 나열 가능
* `--namespace` 또는 `-n` 옵션을 통해 네임스페이스를 명시적으로 지정 가능

### 3.7.3 네임스페이스 생성
> 네임스페이스도 쿠버네티스 리소스라서 YAML 파일과 `kubectl create -f` 명령을 통해 생성 가능

#### YAML 파일에서 네임스페이스 생성
```yaml
apiVersion: v1
kind: Namespace
metadata:
  name: custom-namespace
```

#### kubectl create namespace 명령으로 네임스페이스 생성
> 또는 간단하게 YAML 파일 없이 명령어만으로도 생성 가능
```shell
$ kubectl create namespace custom-namespace
```

### 3.7.4 다른 네임스페이스의 오브젝트 관리
* 다른 네임스페이스의 오브젝트를 대상으로 작업할 때는 `--namespace(또는 -n)` 플래그를 사용
* 만약 네임스페이스를 지정하지 않으면 `kubectl` 컨텍스트에 구성된 기본 네임스페이스에서 작업 진행
* `kubectl config` 명령으로 현재 컨텍스트, 네임스페이스 변경 가능

## 3.8 파드 중지와 제거
### 3.8.1 이름으로 파드 삭제
```shell
$ kubectl delete po kubia-gpu
```
* 파드를 삭제하면 쿠버네티스는 파드 안의 모든 컨테이너를 종료하도록 지시
* `SIGTERM` 신호를 프로세스에 보내고 지정된 시간(default 30초) 동안 기다림
* 시간 내에 종료되지 않으면 `SIGKILL` 신호를 통해 종료
  * 즉, 프로세스가 정상 종료되게 하기 위해서는 `SIGTERM` 신호를 적절히 처리해야 함

### 3.8.2 레이블 셀럭터를 이용한 파드 삭제
```shell
$ kubectl delete po -l creation_method=manual
```
* 셀렉터 조건을 만족하는 파드를 모두 지울 수 있음

### 3.8.3 네임스페이스 제거를 이용한 파드 삭제
```shell
$ kubectl delete ns custom-namespace
```
* 네임스페이스 전체를 삭제하면 파드는 자동으로 함께 삭제됨

### 3.8.4 네임스페이스는 유지하면서 네임스페이스 안의 모든 파드 삭제
```shell
$ kubectl delete po --all
```
* `--all` 명령을 이용해 현재 네임스페이스에 있는 모든 파드 삭제
* 파드를 삭제해도 `ReplicaSet` 등으로 관리되는 파드는 계속 생성됨

### 3.8.5 네임스페이스에서 (거의) 모든 리소스 삭제
```shell
$ kubectl delete all --all
```
* 모든 유형의 리소스 인스턴스 삭제
> 💡 특정 리소스(시크릿 등)는 보존돼 있으며, 명시적으로 삭제해야 함