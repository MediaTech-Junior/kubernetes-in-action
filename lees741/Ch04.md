# Ch04. 레플리케이션과 그 밖의 컨트롤러: 관리되는 파드 배포

## 4.1 파드를 안정적으로 유지하기
> 파드 안에 있는 컨테이너가 죽으면 어떻게 될까?

- 컨테이너의 주 프로세스에 크래시가 발생하면 `kubelet`이 컨테이너 재시작
- 프로세스 크래시없이 애플리케이션이 중단되는 경우 존재
- 애플리케이션이 무한 루프나 데드락 상태에 빠져서 응답하지 않는 상황에서는 애플리케이션 외부에서 상태 체크해야 함

### 4.1.1 라이브니스 프로브
- 파드 생성시 스펙에 각 컨테이너의 liveness probe를 지정할 수 있음 (`spec.linevessProbe`)
- 쿠버네티스가 주기적으로 프로브 실행하고 실패할 경우 컨테이너 재시작
- 컨테이너 재시작시에는 현재 컨테이너를 완전히 종료하고 새로운 컨테이너를 생성

#### HTTP GET 프로브
- 지정한 IP 주소, 포트, 경로에 HTTP GET 요청 보냄
- 응답 코드가 4XX, 5XX아닌 경우 프로브 성공

#### TCP 소켓 프로브
- 컨테이너에 지정된 포트에 TCP 연결 시도
- 연결 성공하면 프로브 성공

#### Exec 프로브
- 컨테이너 내부에서 임의의 명령 실행하고 명령의 종료 상태 코드 확인
- 상태 코드가 0이면 프로브 성공

### 4.1.4 라이브니스 프로브의 추가 속성 설정
> 라이브니스 프로브를 정의할 때 프로브에 관한 추가적인 속성을 설정할 수 있다.
- `delay`: 컨테이너가 시작된 후 프로브를 시작하기까지 지연 시간 옵션 (애플리케이션 시작 시간 고려)
- `timeout`: 프로브의 응답 제한시간, 넘으면 프로브 실패로 간주
- `period`: 프로브를 수행하는 주기
- `failure`: 연속으로 몇 번 프로브 실패해야 재시작할지

### 4.1.5 효과적인 라이브니스 프로브 생성
> 운영 환경에서 실행 중인 파드는 반드시 라이브니스 프로브를 정의하는 것이 좋다.

#### 라이브니스 프로브가 확인해야 할 사항
- 애플리케이션 내부만 체크하고 외부 요인의 영향을 받지 않도록 해야 함.
  - ex. 프론트엔드 서버 라이브니스 프로브는 백엔드 DB 연결에 영향을 받지 않아야 함.

#### 프로브를 가볍게 유지하기
- 보통 프로브는 자주 실행되며 1초 내에 완료돼야 함 

#### 프로브에 재시도 루프를 구현하지 마라
- 프로브의 실패 임곗값을 설정할 수 있으며, 컨테이너가 강제 종료되려면 프로브가 여러 번 실패해야 함
- 실패 임곗값을 1로 설정해도 쿠버네티스가 실패를 인식하기 전에 프로브를 여러 번 재시도

## 4.2 레플리케이션컨트롤러 소개
> 노드 자체에 크래시가 발생한 경우 중단된 모든 파드의 대체 파드를 생성해야 한다.
> 이 경우에는 `kubelet`에서 아무것도 할 수 없기 때문에 이 작업은 컨트롤 플레인의 몫이다.
> 컨트롤 플레인은 레플리케이션컨트롤러 또는 이와 유사한 메커니즘으로 파드를 관리한다.
> 
> 컨트롤 플레인의 관리를 받지 않는 파드를 관리되지 않는 파드(Unmanaged Pods)라고 부른다.

- 어떤 이유에서든 파드가 사라지면,(노드가 죽거나 노드에서 파드가 제거된 경우) 레플리케이션컨트롤러는 사라진 파드를 감지해 교체 파드를 생성
- 노드에 장애가 발생한 뒤 관리되지 않는 파드는 완전히 유실됨
- 일반적으로 레플리케이션컨트롤러는 파드의 여러 복제본(레플리카)을 관리하기 위한 것

### 4.2.1 레플리케이션컨트롤러의 동작
- 실행 중인 파드 목록 지속적으로 모니터링하고 특정 레이블 셀렉터와 일치하는 파드 수가 의도하는 수와 일치하는지 확인
- 파드가 너무 적게 실행 중인 경우 파드 템플릿에서 새 레플리카 생성, 너무 많은 경우 실행 중인 레플리카 제거
#### 의도한 것보다 많은 레플리카가 생기는 경우
- 누군가 파드를 수동으로 만드는 경우
- 누군가 기존 파드의 레이블 셀렉터를 변경하는 경우
- 누군가 의도하는 파드의 수를 줄이는 경우

#### 레플리케이션컨트롤러의 세 가지 필수 요소 이해
- 레이블 셀렉터: 레플리케이션컨트롤러의 범위에 있는 파드 결정
- 레플리카 수: 실행할 파드의 의도하는 수를 지정
- 파드 템플릿: 새로운 파드 레플리카를 만들 때 사용되는 템플릿

#### 컨트롤러의 레이블 셀렉터 또는 파드 템플릿 변경의 영향 이해
> 레이블 셀렉터와 파드 템플릿을 변경해도 기존 파드에는 영향을 미치지 않는다.
> 오직 레플리카 수의 변경만 기존 파드에 영향을 미친다.
- 레이블 셀렉터를 변경하면 기존 파드가 컨트롤러의 범위를 벗어나므로 관리가 중지됨
- 컨트롤러는 파드를 생성한 후에는 파드의 실제 콘텐츠에 신경쓰지 않기 때문에 템플릿 변경은 새로운 레플리카를 생성할 때만 영향을 미침

#### 레플리케이션컨트롤러 사용 시 이점
- 파드가 사라지면 새 파드를 시작
- 노드에 장애가 발생하면 새로운 노드에 교체 복제본 생성
- 수동 또는 자동으로 쉽게 파드 수평 확장 가능 (HPA)

### 4.2.2 레플리케이션컨트롤러 생성
- 만약 템플릿의 파드 레이블과 컨트롤러의 레이블 셀렉터가 일치하지 않으면 새 파드가 무한정 생성될 수 있음
- 이런 경우를 방지하기 위해 API 서버는 레플리케이션컨트롤러 정의를 검증하고 잘못된 경우 받아들이지 않음
- 파드 셀렉터를 지정하지 않으면 자동으로 템플릿의 레이블로 설정됨 (**이게 제일 좋은 방법 같음**)

### 4.2.6 수평 파드 스케일링
- 레플리케이션컨트롤러의 `replicas` 필드 값 조절을 통해 수평 스케일링이 가능
- `kubectl scale` 명령을 이용해 직접 스케일링을 하거나 `kubectl edit` 명령어를 통해 레플리케이션컨트롤러의 정의를 수정

## 4.3 레플리케이션컨트롤러 대신 레플리카셋 사용하기
> 레플리케이션컨트롤러 대신 차세대 리소스인 레플리카셋을 사용하는 것이 좋다.
> 일반적으로 레플리카셋은 직접 생성하지 않고 디플로이먼트 리소스를 생성할 때 자동 생성된다.

### 4.3.1 레플리카셋과 레플리케이션컨트롤러 비교
- 레플리케이션컨트롤러의 레이블 셀렉터는 특정 레이블이 있는 파드만을 매칭시킬 수 있고 같은 키를 갖는 레이블은 여러 값을 매칭시킬 수 없음
- 반면, 레플리카셋의 파드 셀렉터는 특정 레이블이 없는 파드나 레이블의 값과 상관없이 특정 레이블의 키를 갖는 파드를 매칭시킬 수 있음

### 4.3.4 레플리카셋의 더욱 표현적인 레이블 셀렉터 사용하기
- 레플리카셋은 좀 더 표현적인 레이블 셀렉터를 사용할 수 있음
- 각 표현식은 키, 연산자, 가능한 값으로 이루어져 있음
  - `In`: 레이블의 값이 지정된 값 중 하나와 일치해야 함
  - `NotIn`: 레이블의 값이 지정된 값과 일치하지 않아야 함
  - `Exists`: 값과 상관없이 지정된 키를 가진 레이블이 포함돼야 함 (값 필드를 지정하지 않아야 함)
  - `DoesNotExist`: 지정된 키를 가진 레이블이 포함돼 있지 않아야 함 (값 필드를 지정하지 않아야 함)
- 여러 표현식을 지정하는 경우 모든 표현식이 `true`여야 함

## 4.4 데몬셋을 사용해 각 노드에서 정확히 한 개의 파드 실행하기
> 시스템 수준의 작업을 수행하는 인프라 관련 파드는 정확히 각 노드에 하나의 파드가 실행되어야 하는 경우가 있다.
>
> ex. 로그 수집기, 리소스 모니터, `kube-proxy`

### 4.4.1 데몬셋으로 모든 노드에 파드 실행하기
- 각 노드 수만큼 파드를 만들고 새 노드가 추가되면 새 파드 배포
- 쿠버네티스 스케줄러를 건너뜀
- 레플리카셋과 마찬가지로 파드 템플릿으로 파드를 생성

### 4.4.2 데몬셋을 사용해 특정 노드에서만 파드를 실행하기
- 파드가 노드의 일부에서만 실행되도록 지정하지 않으면 모든 노드에서 파드가 실행됨
- 데몬셋 정의의 일부인 파드 템플릿에서 `node-Selector` 속성을 지정하면 됨

## 4.5 완료 가능한 단일 태스크를 수행하는 파드 실행
> 작업을 완료한 후에 종료되는 태스크만 실행하려는 경우가 있을 것이다.
> 레플리케이션컨트롤러, 레플리카셋, 데몬셋은 지속적인 태스크를 실행한다.
> 쿠버네티스는 잡 리소스로 이런 기능을 지원한다.

### 4.5.1 잡 리소스 소개
- 파드의 컨테이너 내부에서 실행 중인 프로세스가 성공적으로 완료되면 컨테이너를 다시 시작하지 않음
- 노드에 장애가 발생한 경우 해당 노드에 있던 잡이 관리하는 파드는 다른 노드로 스케줄링됨 (레플리카셋과 유사)
- 프로세스가 에러 종료 코드를 리턴할 때 컨테이너를 다시 시작할지 설정 가능

### 4.5.2 잡 리소스 정의
- 잡은 batch API 그룹, v1 버전에 속함 (`apiVersion: batch/v1`)
- `restartPolicy`를 `Always`로 설정할 수 없고 `OnFailure`나 `Never`로 명시해야 함

### 4.5.4 잡에서 여러 파드 인스턴스 실행하기
>두 개 이상의 파드 인스턴스를 생성해 병렬 또는 순차적으로 실행하도록 구성 가능하다.
> 잡 리소스를 정의할 때 스펙에 `completions`와 `parallelism` 속성을 설정하면 된다.

#### 순차적으로 잡 파드 실행하기
- `completions` 값을 설정해 잡의 파드를 몇 번 실행할지 결정
- 파드 중 하나가 실패해도 잡이 새 파드를 생성하므로 전체적으로 `completions`에 설정된 값만큼 실행 가능

#### 병렬로 잡 파드 실행하기
- `parallelism` 값만큼 병렬로 여러 파드를 실행할 수 있음
- 잡이 실행되는 동안 `parallelism` 값을 변경할 수 있으며 이는 레플리카셋을 스케일링하는 것과 유사 (`kubectl scale` 명령 사용 가능)

### 4.5.5 잡 파드가 완료되는 데 걸리는 시간 제한하기
- 파드 스펙에 `activeDeadlineSeconds` 속성을 설정해 파드의 실행 시간 제한 가능
- 만약 파드가 이보다 오래 실행되면 실패로 간주하고 시스템이 종료를 시도함
- 잡의 메니페스트에서 `spec.backoffLimit` 필드를 지정해 실패한 것으로 표시되기 전에 잡을 재시도할 수 있는 횟수 설정 가능

## 4.6 잡을 주기적으로 또는 한 번 실행되도록 스케줄링하기
> 많은 배치 잡이 특정 시간 또는 지정된 간격으로 반복 실행해야 한다.
> 리눅스나 유닉스 같은 운영체제에서 이런 작업을 크론 작업이라 한다.
> 쿠버네티스에서도 이를 지원한다.

### 4.6.1 크론잡 생성하기
- 쿠버네티스에서의 크론 작업은 크론잡 리소스를 만들어 구성 (현재는 `batch/v1`)
- 크론잡 리소스를 생성하면 쿠버네티스는 설정된 시간에 잡 템플릿에 따라 잡 리소스를 생성함
- 크론잡 > 잡 > 파드

#### 스케줄 설정하기
- 크론의 스케줄 형식에 따름
- 분, 시, 일, 월, 요일

### 4.6.2 스케줄된 잡의 실행 방법 이해
> 잡이나 파드가 상대적으로 늦게 생성되고 실행될 수 있다.
- 크론잡 스펙의 `startingDeadlineSeconds` 필드를 지정해 데드라인을 설정할 수 있음
- 두 개의 잡이 동시에 생성되거나 전혀 생성되지 않을 수 있음
  - 멱등성: 여러 번 실행해도 원치 않는 결과가 초래되지 않음을 보장
  - 다음 번 잡 실행이 이전의 누락된 실행에서 완료했어야 할 작업을 수행하는지 확인 필요